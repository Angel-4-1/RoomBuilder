/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.13 .\\public\\models\\Animated Woman.glb -o src/components/Avatar.sx -r public 
*/

import React, { useEffect, useRef, useState, useMemo } from 'react'
import { useGLTF, useAnimations, useFBX } from '@react-three/drei'
import { SkeletonUtils } from "three-stdlib"
import { useFrame, useGraph } from '@react-three/fiber';
import { useAtom } from 'jotai';
import { useGrid } from '../hooks/useGrid';
import { userAtom } from '~/Experience';

const FILE_PATH = '/models/Animated Woman.glb';
const MOVEMENT_SPEED = 0.05;
const ANIMATIONS = {
  IDLE: {
    path: "/models/animations/M_Standing_Idle_001.glb",
    name: "M_Standing_Idle_001"
  },
  WALK: {
    path: "/models/animations/M_Walk_001.glb",
    name: "M_Walk_001",
  },
  DANCE: {
    path: "/models/animations/M_Dances_001.glb",
    name: "M_Dances_001",
  },
};

export function Avatar({
  hairColor = "green",
  topColor = "pink",
  bottomColor = "brown",
  id,
  //avatarUrl = "https://models.readyplayer.me/64970be0e5db1e4d4f0d4693.glb",
  avatarUrl = "/models/character.glb",
  ...props
}) {
  const position = useMemo(() => props.position, []);
  const avatar = useRef();
  const [ path, setPath ] = useState();
  const { gridToVector3 } = useGrid();
  
  const group = useRef();
  const { scene } = useGLTF(avatarUrl);
  
  // Skinned meshes cannot be re-used in threejs without cloning them
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene])
  // useGraph creates two flat object collections for nodes and materials
  const { nodes } = useGraph(clone)

  useEffect(() => {
    const newPath = [];
    props.path?.forEach((gridPosition) => {
      newPath.push(gridToVector3(gridPosition));
    });
    setPath(newPath)
  }, [props.path]);
  
  useEffect(() => {
    console.log( path )
  }, [path]);

  // Load animations
  const { animations: idleAnimation } = useGLTF( ANIMATIONS.IDLE.path );
  // const { animations: walkAnimation } = useFBX( "/models/animations/M_Walk_001.fbx" );
  const { animations: walkAnimation } = useGLTF( ANIMATIONS.WALK.path );
  const { animations: danceAnimation } = useGLTF( ANIMATIONS.DANCE.path );

  // Rename the name of the animation
  // idleAnimation[0].name = "idle";
  // walkAnimation[0].name = "walk";

  // Use animations
  const { actions } = useAnimations([
    idleAnimation[0],
    walkAnimation[0],
    danceAnimation[0],
  ], avatar);

  const [isDancing, setIsDancing] = useState(false);
  const [animation, setAnimation] = useState(ANIMATIONS.IDLE.name);

  useEffect(() => {
    console.log(animation)
    actions[animation]?.reset().fadeIn(0.32).play();

    return () => actions[animation]?.fadeOut(0.32);
  }, [animation])

  // useEffect(() => {
  //   function onPlayerDance(value) {
  //     if( value.id === id) {
  //       setIsDancing(true);
  //     }
  //   }
  //   function onPlayerMove(value) {
  //     if (value.id === id) {
  //       const path = [];
  //       value.path?.forEach((gridPosition) => {
  //         path.push(gridToVector3(gridPosition));
  //       });
  //       setPath(path);
  //     }
  //   }

  //   // socket.on("playerMove", onPlayerMove);
  //   // socket.on("playerDance", onPlayerDance);
  //   // return () => {
  //   //   socket.off("playerDance", onPlayerDance);
  //   //   socket.off("playerMove", onPlayerMove);
  //   // };
  // }, [id])

  const [user] = useAtom(userAtom);

  useFrame((state) => {

    // Some of the ready player me animations are not fixed (they move)
    // so we need to force them not to move
    // the bone of the animation which is causing it is 'Hips'
    const hips = avatar.current.getObjectByName("Hips");
    hips.position.set(0, hips.position.y, 0);
    // console.log( "apath", path )
    if (path?.length && group.current.position.distanceTo(path[0]) > 0.1) {
      console.log("has path")
      const direction = group.current.position
        .clone()
        .sub(path[0])
        .normalize()
        .multiplyScalar(MOVEMENT_SPEED);
      
      group.current.position.sub( direction );
      group.current.lookAt( path[0] );
      setAnimation(ANIMATIONS.WALK.name);
      setIsDancing(false)
    } else if (path?.length) {
      path.shift();
    } else {
      if(isDancing) {
        setAnimation(ANIMATIONS.DANCE.name)
      } else {
        setAnimation(ANIMATIONS.IDLE.name); 
      }
    }

    // Camera to follow character
    if(id === user) {
      state.camera.position.x = group.current.position.x + 8;
      state.camera.position.y = group.current.position.y + 8;
      state.camera.position.z = group.current.position.z + 8;
      state.camera.lookAt( group.current.position );
    }
  })

  useEffect(() => {
    clone.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
      }
    })
  }, [])

  return (
    <group ref={group} {...props} position={position} dispose={null} name={`character-${id}`}>
      <primitive object={clone} ref={avatar}/>
    </group>
  )
}

//useGLTF.preload(FILE_PATH);
useGLTF.preload(ANIMATIONS.IDLE.path);
useGLTF.preload(ANIMATIONS.WALK.path);
useGLTF.preload(ANIMATIONS.DANCE.path);
